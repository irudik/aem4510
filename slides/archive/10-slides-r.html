<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Lecture 10</title>
    <meta charset="utf-8" />
    <meta name="author" content="Ivan Rudik" />
    <script src="10-slides-r_files/header-attrs/header-attrs.js"></script>
    <link href="10-slides-r_files/remark-css/default.css" rel="stylesheet" />
    <link href="10-slides-r_files/remark-css/metropolis.css" rel="stylesheet" />
    <link href="10-slides-r_files/remark-css/metropolis-fonts.css" rel="stylesheet" />
    <link href="10-slides-r_files/tile-view/tile-view.css" rel="stylesheet" />
    <script src="10-slides-r_files/tile-view/tile-view.js"></script>
    <link href="10-slides-r_files/panelset/panelset.css" rel="stylesheet" />
    <script src="10-slides-r_files/panelset/panelset.js"></script>
    <script src="10-slides-r_files/xaringanExtra-webcam/webcam.js"></script>
    <script id="xaringanExtra-webcam-options" type="application/json">{"width":"200","height":"200","margin":"1em"}</script>
    <link rel="stylesheet" href="my-css.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Lecture 10
## Base R // Tidyverse // Regression
### Ivan Rudik
### AEM 4510

---

exclude: true

```r
if (!require("pacman")) install.packages("pacman")
```

```
## Loading required package: pacman
```

```r
pacman::p_load(
  tidyverse, xaringanExtra, rlang, patchwork, nycflights13, broom, viridis, janitor
)
options(htmltools.dir.version = FALSE)
knitr::opts_hooks$set(fig.callout = function(options) {
  if (options$fig.callout) {
    options$echo = FALSE
  }
knitr::opts_chunk$set(echo = TRUE, fig.align="center")
  options
})
red_pink = "#e64173"
# A blank theme for ggplot
theme_empty = theme_minimal() +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_text(size = 24), axis.text.y = element_text(size = 24, color = "#ffffff"),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#ffffff", colour = NA),
    plot.background = element_rect(fill = "#ffffff", colour = NA),
    axis.line = element_line(colour = "black"), axis.ticks = element_line(),
  )
theme_blank = theme_minimal() +
  theme(
    legend.position = "none",
    title = element_text(size = 24),
    axis.text.x = element_blank(), axis.text.y = element_blank(),
    axis.title.x = element_blank(), axis.title.y = element_blank(),
    panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(),
    panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(),
    panel.background = element_rect(fill = "#ffffff", colour = NA),
    plot.background = element_rect(fill = "#ffffff", colour = NA),
    axis.line = element_blank(), axis.ticks = element_blank(),
  ) 
theme_regular = 
  theme_minimal() +
  theme(
    legend.position = "none",
    title = element_text(size = 14),
    axis.text.x = element_text(size = 24), axis.text.y = element_text(size = 24),
    axis.title.x = element_text(size = 24), axis.title.y = element_text(size = 24),
    panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank(),
    panel.grid.major.x = element_blank(), axis.ticks = element_line(),  axis.line = element_line(),
    panel.background = element_rect(fill = "#ffffff", colour = NA),
    plot.background = element_rect(fill = "#ffffff", colour = NA)
  ) 
```


```
## Warning: 'xaringanExtra::style_panelset' is deprecated.
## Use 'style_panelset_tabs' instead.
## See help("Deprecated")
```

```
## Warning in style_panelset_tabs(...): The arguments to `syle_panelset()` changed
## in xaringanExtra 0.1.0. Please refer to the documentation to update your slides.
```

---

# Roadmap

- What is R?
- What is the tidyverse?
- How do we import and manipulate data?

Our goal is to take a hands on approach to learning how we actually .hi-blue[do] environmental economics

A good chunk of this lecture comes from Grant Mcdermott's [data science for economists](https://github.com/uo-ec607/lectures) notes, Ed Rubin's [intro to econometrics](https://github.com/edrubin/EC421S20), and [RStudio education](https://education.rstudio.com/)

---

class: inverse, center, middle
name: r

# RStudio Cloud

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# Getting started

We will be using [rstudio.cloud](https://rstudio.cloud) for our coding

--

Why?

--

You don't need to download/install anything

--

I can prepare the packages and code and make it easy to download

--

Let's get everything going...

---

# Getting started: login 

![](files/login.png)

---

# Getting started: new project

![](files/10-new-project.png)


---

# Getting started: wait for deployment

![](files/deploying.png)

---

# Click on base-code in bottom-right

![](files/10-open-base-code.png)


---

# Code script open!

![](files/10-coding-window.png)

---

# Now we're set

Now we're all set with our coding environment

--

You can write code in the top window and save it as a file

--


Or you can just enter it in the console in the bottom if you don't want to save it

--

Highlight code in the top window and press cmd+enter to run those highlighted lines

---

class: inverse, center, middle
name: r

# Quick intro to R

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---
class: inverse, center, middle
name: intro

# Introduction to base R

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---

# Basic arithmetic

R is a powerful calculator and recognizes all of the standard arithmetic operators:


```r
1+2 # add / subtraction
```

```
## [1] 3
```

```r
5/2 # divide
```

```
## [1] 2.5
```

```r
2^3 # exponentiate
```

```
## [1] 8
```

```r
2+4*1^3 # standard order of precedence (`*` before `+`, etc.)
```

```
## [1] 6
```

---

# Logic

R also comes equipped with a full set of logical operators and Booleans


```r
1 &gt; 2
```

```
## [1] FALSE
```

```r
(1 &gt; 2) &amp; (1 &gt; 0.5) # "&amp;" is the "and" operator
```

```
## [1] FALSE
```

```r
(1 &gt; 2) | (1 &gt; 0.5) # "|" is the "or" operator
```

```
## [1] TRUE
```

---

# Logic

We can negate expressions with: `!`

This is helpful for filtering data


```r
is.na(1:10)
```

```
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
```

```r
!is.na(1:10)
```

```
##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
```

`NA` means **not available** (i.e., missing)

---

# Logic

For value matching we can use: `%in%`

To see whether an object is contained within (i.e., matches one of) a list of items, use `%in%`:

```r
4 %in% 1:10
```

```
## [1] TRUE
```

```r
4 %in% 5:10
```

```
## [1] FALSE
```

---

# Logic

To evaluate whether two expressions are equal, we need to use **two** equal signs


```r
1 = 1 # This doesn't work
```

```
## Error in 1 = 1: invalid (do_set) left-hand side to assignment
```

```r
1 == 1 # This does.
```

```
## [1] TRUE
```

```r
1 != 2 # Note the single equal sign when combined with a negation.
```

```
## [1] TRUE
```

---

# Logic

**Evaluation caveat:** What do you think will happen if we evaluate `0.1 + 0.2 == 0.3`?

--


```r
0.1 + 0.2 == 0.3
```

```
## [1] FALSE
```
Uh-oh! What went wrong here?

--

**Problem:** Computers represent numbers as binary (i.e., base 2) floating-points. More [here](https://floating-point-gui.de/basic/)
- Fast and memory efficient, but can lead to unexpected behavior
- Similar to how standard decimals can't precisely capture certain fractions (e.g., `\(\frac{1}{3} = 0.3333...\)`)

--

**Solution:** Use `all.equal()` for evaluating floats (i.e., fractions)


```r
all.equal(0.1 + 0.2, 0.3)
```

```
## [1] TRUE
```

---

# Assignment

In R, we can use either `&lt;-` or `=` to handle assignment

--

### Assignment with `=`

`&lt;-` is normally read aloud as "gets". You can think of it as a (left-facing) arrow saying *assign in this direction*.


```r
a = 10 + 5
a
```

```
## [1] 15
```

---

# Assignment

### Assignment with `=`

You can also use `=` for assignment.


```r
b = 10 + 10
b
```

```
## [1] 20
```

---

# Which assignment operator should you use?

The proper one to use is `&lt;-`, which can be inserted using the keyboard shortcut Alt/Option + -

It doesn't really matter for our purposes, other languages use `=`

I will use `=`

**Bottom line:** Use whichever you prefer, just be consistent

---

# Help

For more information on a (named) function or object in R, consult the "help" documentation using `?`

For example:

```R
?plot 
```

---

# Vignettes

For some packages, `vignette()` will provide a detailed intro


```r
# Try this:
vignette("dplyr")
```

Vignettes are a great way to learn how and when to use a package

---

# Comments


Comments in R code are demarcated by `#`

Use comments to document your logic in `.R` scripts and within `.Rmd` code chunks


```r
# THIS IS A CODE SECTION ----
# this is a comment
cornell = "big red" 
```

--

Comments should be concise and used only when necessary (unlike the comments above)

---

# Comments


```r
# THIS IS A CODE SECTION ----
# this is a comment
cornell = "big red"
```

Using at least four trailing dashes (`----`) creates a code section, which simplifies navigation and code folding
- Also works with trailing equals (`====`) or pound signs (`####`)

--

**Keyboard shortcut:** use `Ctrl/Cmd+/` or `Ctrl/Cmd+Shift+C` in RStudio to (un)comment whole sections of highlighted code


---
class: inverse, center, middle
name: oop

# Object-oriented programming in R

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---

# Object-oriented programming

In R:

&gt; **"Everything is an object and everything has a name."**

---
class: inverse, center, middle
name: eobject

# "Everything is an object"


---

# What are objects? 

There are many different *types* (or *classes*) of objects

Here are some objects that we'll be working with regularly:
- vectors
- matrices
- data frames
- lists
- functions


---

# Data frames

The most important object we will be working with is the **data frame**

You can think of it basically as an Excel spreadsheet


```r
# Create a small data frame called "d"
d = data.frame(x = 1:2, y = 3:4) 
d
```

```
##   x y
## 1 1 3
## 2 2 4
```

--

This is essentially just a table with columns named `x` and `y`

--

Each row is an observation telling us the values of both `x` and `y`

---

# Aside: built-in data frames

Base R and packages have a bunch of built in data frames with special names you can call on

For example we have `cars`:

.pull-left[

```r
head(cars)
```

```
##   speed dist
## 1     4    2
## 2     4   10
## 3     7    4
## 4     7   22
## 5     8   16
## 6     9   10
```
]

.pull-right[

```r
plot(cars)
```

![](10-slides-r_files/figure-html/plot-cars-1.png)&lt;!-- --&gt;
]



---

# Back to objects

Each object class has its own set of rules for determining valid operations


```r
# Create a small data frame called "d"
d = data.frame(x = 1:2, y = 3:4) 
d
```

```
##   x y
## 1 1 3
## 2 2 4
```

---

# Back to objects

At the same time, you can (usually) convert an object from one type to another


```r
# Convert it to (i.e., create) a matrix call "mat"
mat = as.matrix(d)
mat
```

```
##      x y
## [1,] 1 3
## [2,] 2 4
```

---

# Working with multiple objects

In R we can have multiple data frames in memory at once

Even though we just made `mat`, `d` still exists:


```r
d
```

```
##   x y
## 1 1 3
## 2 2 4
```

---

# Ways to learn about objects

Printing an object directly in the console is often handy
- e.g., Type `d` and hit Enter

--

`View()` is very helpful, and has the same effect as clicking on the object in your RStudio *Environment* pane
- e.g., Type `View(d)` and hit Enter

---

# Ways to learn about objects

Use the `str` command to learn about an object's **str**ucture


```r
# d = data.frame(x = 1:2, y = 3:4) # Create a small data frame called "d"
str(d) # Evaluate its structure
```

```
## 'data.frame':	2 obs. of  2 variables:
##  $ x: int  1 2
##  $ y: int  3 4
```

--

You can also use `class` to get an object's class without all the other details


---
name: global_env

# Global environment

Let's go back to the simple data frame that we created a few slides earlier.

```r
d
```

```
##   x y
## 1 1 3
## 2 2 4
```

--

Now, let's try to do a logical comparison of these "x" and "y" variables:


```r
x &lt; y
```

```
## Error in eval(expr, envir, enclos): object 'x' not found
```

--

Uh-oh. What went wrong here?

---

# Global environment

The error message provides the answer to our question:

```
*## Error in eval(predvars, data, env): object 'x' not found
```

--

R looked in our *Global Environment* and couldn't find `x`

&lt;img src="files/02-environment.png" width="75%" /&gt;

--

We have to tell R that `x` and `y` belong to the object `d`

We will come back to this



---
class: inverse, center, middle
name: ename

# "Everything has a name"

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---

# Reserved words

R has a bunch of key/reserved words that serve specific functions
- You can't (re)assign these, even if you wanted to

See [here](http://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html) for a full list, including (but not limited to):

```R
if
else
while # looping
function
for # looping
TRUE
FALSE
NULL # null/undefined
Inf #infinity
NaN # not a number
NA # not available / missing
```

---

# Semi-reserved words

There are other words that are sort of reserved, in that they have a particular meaning
- These are named functions or constants (e.g., `pi`) that you can re-assign if you really want to... but that already come with important meanings from base R

The most important example is `c()`, which binds and concatenates objects together


```r
my_vector = c(1, 2, 5)
my_vector
```

```
## [1] 1 2 5
```

---

# Semi-reserved words

What do you think will happen if you type the following?


```r
c = 4
c(1, 2 ,5)
```

--


```
## [1] 1 2 5
```

--

In this case, R is "smart" enough to distinguish between the variable `c` and the built-in function `c()`

---

# Semi-reserved words (cont.)

But R won't always be able to distinguish between conflicting definitions! For example:

```r
pi
```

```
## [1] 3.141593
```

```r
pi = 2
pi
```

```
## [1] 2
```
--

**Bottom line:** Don't use (semi-)reserved words!


---
class: inverse, center, middle
name: indexing

# Indexing

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;



---

# Indexing

How do we index in R?

--

We've already seen an example of indexing in the form of R console output:


```r
1+2
```

```
## [1] 3
```

The `[1]` above denotes the ﬁrst (and, in this case, only) element of our output

--

In this case, a vector of length one equal to the value "3"

---

# Indexing

Try the following in your console to see a more explicit example of indexed output:


```r
rnorm(n = 50, mean = 0, sd = 1) # take 50 draws from the standard normal distribution
```

--


```
##  [1]  1.62295858 -0.55469929  0.46628731 -1.65669765 -0.86058426  0.83158347
##  [7]  1.64737544  0.39299903  0.09431285 -1.27440466  1.40794961  0.30169538
## [13]  2.24490962 -0.09224972  2.02745594  2.07531253 -0.23003648 -1.18919684
## [19] -1.34631467 -1.34120251  1.05576193  0.80117986  0.52700501  0.12804045
## [25] -1.32675305 -1.56985114 -0.33249858  1.47752658 -0.56441158  0.73609594
## [31]  1.75009711  0.10072173  0.77832664 -0.73818997  0.15799774  0.29318796
## [37] -0.33782394 -0.58011189 -1.20873018 -0.89561165  1.99983961  0.46884044
## [43]  0.33656194 -0.52128777  0.64874559  0.20858868 -0.01103537 -0.16479979
## [49]  0.04249935 -1.66497370
```


---

# Option 1: []

We can use `[]` to index objects that we create in R

```r
a = 1:10
a[4] ## Get the 4th element of object "a"
```

```
## [1] 4
```

```r
a[c(4, 6)] ## Get the 4th and 6th elements
```

```
## [1] 4 6
```

---

# Option 1: []

This also works on larger arrays (vectors, matrices, data frames, and lists)

```r
starwars[1, 1] ## Show the cell corresponding to the 1st row &amp; 1st column of the data frame.
```

```
## # A tibble: 1 × 1
##   name          
##   &lt;chr&gt;         
## 1 Luke Skywalker
```

--

What does `starwars[1:3, 1]` give you?

--


```
## # A tibble: 3 × 1
##   name          
##   &lt;chr&gt;         
## 1 Luke Skywalker
## 2 C-3PO         
## 3 R2-D2
```


---

# Option 1: []

We haven't discusssed them yet, but **lists** are a more complex type of array object in R

--

They can contain a collection of objects that don't share the same structure

--

For example, you can have lists containing:

- a scalar, a string, and a data frame
- a list of data frames
- a list of lists

---

# Option 1: []

The relevance to indexing is that lists require two square brackets `[[]]` to index the parent list item and then the standard `[]` within that parent item. An example might help to illustrate:

```r
my_list = list(
a = "hello",
b = c(1,2,3),
c = data.frame(x = 1:5, y = 6:10))
my_list[[1]] # Return the 1st list object
```

```
## [1] "hello"
```

```r
my_list[[2]][3] # Return the 3rd element of the 2nd list object
```

```
## [1] 3
```

---

# Option 2: $


Lists provide a nice segue to our other indexing operator: `$`
- Let's continue with the `my_list` example from the previous slide.


```r
my_list
```

```
## $a
## [1] "hello"
## 
## $b
## [1] 1 2 3
## 
## $c
##   x  y
## 1 1  6
## 2 2  7
## 3 3  8
## 4 4  9
## 5 5 10
```

---
count: false

# Option 2: $


Lists provide a nice segue to our other indexing operator: `$`.
- Let's continue with the `my_list` example from the previous slide


```r
my_list
```

```
*## $a
## [1] "hello"
##
*## $b
## [1] 1 2 3
##
*## $c
##   x  y
## 1 1  6
## 2 2  7
## 3 3  8
## 4 4  9
## 5 5 10
```

Notice how our (named) parent list objects are demarcated: `$a`,`$b` and `$c`

---

# Option 2: $

We can call these objects directly by name using the dollar sign, e.g.

```r
my_list$a ## Return list object "a"
```

```
## [1] "hello"
```

```r
my_list$b[3] ## Return the 3rd element of list object "b"
```

```
## [1] 3
```

```r
my_list$c$x ## Return column "x" of list object "c"
```

```
## [1] 1 2 3 4 5
```

???

**Aside:** Typing `View(my_list)` (or, equivalently, clicking on the object in RStudio's environment pane) provides a nice interactive window for exploring the nested structure of lists.

---

# Option 2: $

The `$` form of indexing also works for other object types

In some cases, you can also combine the two index options:

```r
starwars$name[1]
```

```
## [1] "Luke Skywalker"
```

???

Note some key differences between the output from this example and that of our previous `starwars[1, 1]` example. What are they?
- Hint: Apart from the visual cues, try wrapping each command in `str()`.

---

# Option 2: $

Finally, `$` provides another way to avoid the "object not found" problem that we ran into earlier


```r
x &lt; y # Doesn't work
```

```
## Error in eval(expr, envir, enclos): object 'x' not found
```

```r
d$x &lt; d$y # Works!
```

```
## [1] TRUE TRUE
```

---
class: inverse, center, middle
name: cleaning

# Cleaning up

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---

# Removing objects

Use `rm()` to remove an object or objects from your working environment

```r
a = "hello"
b = "world"
rm(a, b)
```

You can use `rm(list = ls())` to remove all objects in your working environment, though this is [frowned upon](https://www.tidyverse.org/articles/2017/12/workflow-vs-script/)
- Better just to start a new R session

---

class: inverse, center, middle
name: tidyverse

# The tidyverse

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# What is "tidy" data?

What we are going to learn is how to use a set of packages called the .hi[tidyverse]

--

These sets of packages make working with data .hi-blue[extremely easy] and .hi-blue[intuitive]

---

# What is "tidy" data?

Resources:
- [Vignette](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) (from the **tidyr** package)
- [Original paper](https://vita.had.co.nz/papers/tidy-data.pdf) (Hadley Wickham, 2014 JSS)

--

Key points:
1. Each variable forms a column.
2. Each observation forms a row.
3. Each type of observational unit forms a table.

--

Basically, tidy data is more likely to be [long (i.e. narrow)](https://en.wikipedia.org/wiki/Wide_and_narrow_data) than wide

---

# Checklist

Install tidyverse: `install.packages('tidyverse')` (already done on cloud)

Install nycflights13: `install.packages('nycflights13', repos = 'https://cran.rstudio.com')`

---

# Tidyverse vs. base R

Lots of debate over tidyverse vs base R

--

The answer is [obvious](http://varianceexplained.org/r/teach-tidyverse/): We should teach the tidyverse first
- Good documentation and support
- Consistent philosophy and syntax
- Nice front-end for big data tools
- For data cleaning, plotting, the tidyverse is elite

---

# Tidyverse vs. base R

Base R is still great
- Base R is extremely flexible and powerful
- The tidyverse can't do everything
- Using base R and the tidyverse together is often a good idea

---

# Tidyverse vs. base R

One point of convenience is that there is often a direct correspondence between a tidyverse command and its base R equivalent:

| tidyverse  |  base |
|---|---|
| `?readr::read_csv`  | `?utils::read.csv` |
|  `?dplyr::if_else` |  `?base::ifelse` |
|  `?tibble::tibble` |  `?base::data.frame` |

Tidyverse functions typically have extra features on top of base R

--

There are always many ways to achieve a single goal in R

---

# Tidyverse packages

Let's load the tidyverse meta-package and check the output.

```r
library(tidyverse)
```

--

We have actually loaded a number of packages: **ggplot2**, **tibble**, **dplyr**, etc

--

We can also see information about the package versions and some [namespace conflicts](https://raw.githack.com/uo-ec607/lectures/master/04-rlang/04-rlang.html#59)

---

# Tidyverse packages

The tidyverse actually comes with a lot more packages than those that are just loaded automatically

```r
tidyverse_packages()
```

```
##  [1] "broom"         "cli"           "crayon"        "dbplyr"       
##  [5] "dplyr"         "dtplyr"        "forcats"       "googledrive"  
##  [9] "googlesheets4" "ggplot2"       "haven"         "hms"          
## [13] "httr"          "jsonlite"      "lubridate"     "magrittr"     
## [17] "modelr"        "pillar"        "purrr"         "readr"        
## [21] "readxl"        "reprex"        "rlang"         "rstudioapi"   
## [25] "rvest"         "stringr"       "tibble"        "tidyr"        
## [29] "xml2"          "tidyverse"
```

e.g. the **lubridate** package is for working with dates and the **rvest** package is for webscraping

--

These packages have to be loaded separately

---

# Tidyverse packages

We're going to focus on two workhorse packages:
1. [**dplyr**](https://dplyr.tidyverse.org/)
2. [**tidyr**](https://tidyr.tidyverse.org/)

These are the packages for cleaning and wrangling data

--

They are thus the ones that you will likely make the most use of

--

Data cleaning and wrangling is important and knowing how to do it well is a good skill for any data-oriented job

---

# Pipes: |&gt;

The pipe operator `|&gt;` lets us perform a sequence of operations in a very nice and tidy way

--

Let's consider a fake example to get the idea for why its really beneficial
                                                                                      
---

# Pipes: |&gt;

Let's say we wanted to apply a sequence of operations that tells the computer what you did throughout your day:

1. Wake up
2. Get out of bed
3. Comb hair
4. Go downstairs
5. Drink a cup
6. Grab hat
7. Catch bus

---

# Pipes: |&gt;

If you were to code this up in a traditional way it might look one of two ways:

A bunch of lines doing all the different steps

```r
me = wake_up(me)
me = get_out_of_bed(me)
me = comb_hair(me)
me = go(me, "downstairs")
me = drink(me, "cup")
me = grab(me, "hat")
me = catch(me, "bus")
```

---

# Pipes: |&gt;

If you were to code this up in a traditional way it might look one of two ways:

Or if you're a little crazy then do it all in one line

```r
me = catch(grab(drink(go(comb_hair(get_out_of_bed(wake_up(me))), where = "downstairs"), what = "cup"), what = "hat"), what = "bus")
```

These are kind of tedious or messy and out of the order you'd think

---

# Pipes: |&gt;

With pipes we can do everything at once, but have it be .hi[in order]:


```r
me = me |&gt;
wake_up() |&gt;
get_out_of_bed() |&gt;
comb_hair() |&gt;
go("downstairs") |&gt;
drink("cup") |&gt;
grab("hat") |&gt;
catch("bus") 
```

This makes everything .hi[very intuitive] to read and code!


---

# Pipes: |&gt;

Here's a real example: suppose we wanted to figure out the average highway miles per gallon of Audi's in the `mpg` dataset:

```r
mpg
```

```
## # A tibble: 234 × 11
##    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class
##    &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
##  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…
##  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…
##  3 audi         a4           2    2008     4 manu… f        20    31 p     comp…
##  4 audi         a4           2    2008     4 auto… f        21    30 p     comp…
##  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…
##  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…
##  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…
##  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…
##  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…
## 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…
## # … with 224 more rows
```

---

# Pipes: |&gt;

There's two ways you might do this without taking advantage of pipes:

--

The first is to do it step-by-step, line-by-line which requires a lot of variable assignment


```r
audis_mpg = filter(mpg, manufacturer=="audi")
audis_mpg_grouped = group_by(filter(mpg, manufacturer=="audi"), model)
summarise(audis_mpg_grouped, hwy_mean = mean(hwy))
```

```
## # A tibble: 3 × 2
##   model      hwy_mean
##   &lt;chr&gt;         &lt;dbl&gt;
## 1 a4             28.3
## 2 a4 quattro     25.8
## 3 a6 quattro     24
```

---

# Pipes: |&gt;

Next you could do it all in one line which is hard to read


```r
summarise(group_by(filter(mpg, manufacturer=="audi"), model), hwy_mean = mean(hwy))
```

```
## # A tibble: 3 × 2
##   model      hwy_mean
##   &lt;chr&gt;         &lt;dbl&gt;
## 1 a4             28.3
## 2 a4 quattro     25.8
## 3 a6 quattro     24
```

---

# Pipes: |&gt;

Or, you could use .hi-blue[pipes] `|&gt;`:


```r
mpg |&gt; filter(manufacturer=="audi") |&gt; group_by(model) |&gt; summarise(hwy_mean = mean(hwy))
```

```
## # A tibble: 3 × 2
##   model      hwy_mean
##   &lt;chr&gt;         &lt;dbl&gt;
## 1 a4             28.3
## 2 a4 quattro     25.8
## 3 a6 quattro     24
```

--

It performs the operations from left to right, exactly like you'd think of them: take this object (mpg), do this (filter), then do this (group by car model), then do this (take the mean of highway miles)


---

# Use vertical space

Pipes are even more readable if we write it over several lines:

```r
mpg |&gt;
filter(manufacturer=="audi") |&gt;
group_by(model) |&gt;
summarise(hwy_mean = mean(hwy))
```

```
## # A tibble: 3 × 2
##   model      hwy_mean
##   &lt;chr&gt;         &lt;dbl&gt;
## 1 a4             28.3
## 2 a4 quattro     25.8
## 3 a6 quattro     24
```

Using vertical space costs nothing and makes for much more readable code

---
class: inverse, center, middle
name: dplyr

# dplyr

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# Aside: dplyr 1.0.0 release

Please make sure that you are running at least **dplyr** 1.0.0 before continuing.


```r
packageVersion("dplyr")
```

```
## [1] '1.0.8'
```

```r
# install.packages('dplyr') ## install updated version if &lt; 1.0.0
```


---

# The five key dplyr verbs

1. `filter`: Subset/filter rows based on their values

2. `arrange`: Reorder/arrange rows based on their values

3. `select`: Select columns/variables

4. `mutate`: Create new columns/variables

5. `summarise`: Collapse multiple rows into a single summary value, potentially by a grouping variable

--

Let's practice these commands together using the `starwars` data frame that comes pre-packaged with dplyr

---

# Starwars

Here's the `starwars` dataset, it has 87 observations of 14 variables

```r
starwars
```

```
## # A tibble: 87 × 14
##    name     height  mass hair_color skin_color eye_color birth_year sex   gender
##    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
##  1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…
##  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu…
##  3 R2-D2        96    32 &lt;NA&gt;       white, bl… red             33   none  mascu…
##  4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
##  5 Leia Or…    150    49 brown      light      brown           19   fema… femin…
##  6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
##  7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…
##  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu…
##  9 Biggs D…    183    84 black      light      brown           24   male  mascu…
## 10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…
## # … with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
## #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```


---

# 1) dplyr::filter

Why filter?

--

Filtering subsets your data

--

This means that you can take out data that meet certain characteristics

--

e.g. if you want to run your analysis only on low income areas, or if you want to focus on years after 2005

---

# 1) dplyr::filter

Here we are subsetting the observations of humans that are at least 190cm

```r
starwars |&gt;
filter(
  species == "Human",
  height &gt;= 190
)
```

```
## # A tibble: 4 × 14
##   name      height  mass hair_color skin_color eye_color birth_year sex   gender
##   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
## 1 Darth Va…    202   136 none       white      yellow          41.9 male  mascu…
## 2 Qui-Gon …    193    89 brown      fair       blue            92   male  mascu…
## 3 Dooku        193    80 white      fair       brown          102   male  mascu…
## 4 Bail Pre…    191    NA black      tan        brown           67   male  mascu…
## # … with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
## #   vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# 1) dplyr::filter

You can filter using regular expressions with grep-type commands or the `stringr` package

```r
starwars |&gt;
filter(stringr::str_detect(name, "Skywalker"))
```

```
## # A tibble: 3 × 14
##   name      height  mass hair_color skin_color eye_color birth_year sex   gender
##   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
## 1 Luke Sky…    172    77 blond      fair       blue            19   male  mascu…
## 2 Anakin S…    188    84 blond      fair       blue            41.9 male  mascu…
## 3 Shmi Sky…    163    NA black      fair       brown           72   fema… femin…
## # … with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
## #   vehicles &lt;list&gt;, starships &lt;list&gt;
```

This subsets the observations for individuals whose names contain "Skywalker"

---

# 1) dplyr::filter

A very common `filter` use case is identifying/removing missing data cases:

```r
starwars |&gt;
filter(is.na(height))
```

```
## # A tibble: 6 × 14
##   name      height  mass hair_color skin_color eye_color birth_year sex   gender
##   &lt;chr&gt;      &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
## 1 Arvel Cr…     NA    NA brown      fair       brown             NA male  mascu…
## 2 Finn          NA    NA black      dark       dark              NA male  mascu…
## 3 Rey           NA    NA brown      light      hazel             NA fema… femin…
## 4 Poe Dame…     NA    NA brown      light      brown             NA male  mascu…
## 5 BB8           NA    NA none       none       black             NA none  mascu…
## 6 Captain …     NA    NA unknown    unknown    unknown           NA &lt;NA&gt;  &lt;NA&gt;  
## # … with 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;,
## #   vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# 1) dplyr::filter

To remove missing observations, use negation:

```r
starwars |&gt;
  filter(!is.na(height))
```

```
## # A tibble: 81 × 14
##    name     height  mass hair_color skin_color eye_color birth_year sex   gender
##    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
##  1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…
##  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu…
##  3 R2-D2        96    32 &lt;NA&gt;       white, bl… red             33   none  mascu…
##  4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
##  5 Leia Or…    150    49 brown      light      brown           19   fema… femin…
##  6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
##  7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…
##  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu…
##  9 Biggs D…    183    84 black      light      brown           24   male  mascu…
## 10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…
## # … with 71 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
## #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# 2) dplyr::arrange

`arrange` sorts the data frame based on the variables you supply:

```r
starwars |&gt;
  arrange(birth_year)
```

```
## # A tibble: 87 × 14
##    name     height  mass hair_color skin_color eye_color birth_year sex   gender
##    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
##  1 Wicket …     88  20   brown      brown      brown            8   male  mascu…
##  2 IG-88       200 140   none       metal      red             15   none  mascu…
##  3 Luke Sk…    172  77   blond      fair       blue            19   male  mascu…
##  4 Leia Or…    150  49   brown      light      brown           19   fema… femin…
##  5 Wedge A…    170  77   brown      fair       hazel           21   male  mascu…
##  6 Plo Koon    188  80   none       orange     black           22   male  mascu…
##  7 Biggs D…    183  84   black      light      brown           24   male  mascu…
##  8 Han Solo    180  80   brown      fair       brown           29   male  mascu…
##  9 Lando C…    177  79   black      dark       brown           31   male  mascu…
## 10 Boba Fe…    183  78.2 black      fair       brown           31.5 male  mascu…
## # … with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
## #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# 1) dplyr::arrange

Why arrange?

--

Arrange sorts your data

--

This makes it easy to check and see patterns in the data

---

# 2) dplyr::arrange

We can also arrange items in descending order using `arrange(desc())`

```r
starwars |&gt;
  arrange(desc(birth_year))
```

```
## # A tibble: 87 × 14
##    name     height  mass hair_color skin_color eye_color birth_year sex   gender
##    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
##  1 Yoda         66    17 white      green      brown            896 male  mascu…
##  2 Jabba D…    175  1358 &lt;NA&gt;       green-tan… orange           600 herm… mascu…
##  3 Chewbac…    228   112 brown      unknown    blue             200 male  mascu…
##  4 C-3PO       167    75 &lt;NA&gt;       gold       yellow           112 none  mascu…
##  5 Dooku       193    80 white      fair       brown            102 male  mascu…
##  6 Qui-Gon…    193    89 brown      fair       blue              92 male  mascu…
##  7 Ki-Adi-…    198    82 white      pale       yellow            92 male  mascu…
##  8 Finis V…    170    NA blond      fair       blue              91 male  mascu…
##  9 Palpati…    170    75 grey       pale       yellow            82 male  mascu…
## 10 Cliegg …    183    NA brown      fair       blue              82 male  mascu…
## # … with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
## #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# 3) dplyr::select

Why select?

--

Select lets you choose columns to keep or drop

--

This means you are essentially getting rid of variables, likely ones you do not need

--

e.g. if you used an emissions rate and marginal damage per unit of pollution variable to construct the marginal damage of output, you may not need the first two variables any more

---

# 3) dplyr::select

Use commas to select multiple columns out of a data frame, deselect a column with "-", select across multiple columns with "first:last":

```r
starwars |&gt;
  select(name:skin_color, species, -height)
```

```
## # A tibble: 87 × 5
##    name                mass hair_color    skin_color  species
##    &lt;chr&gt;              &lt;dbl&gt; &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;  
##  1 Luke Skywalker        77 blond         fair        Human  
##  2 C-3PO                 75 &lt;NA&gt;          gold        Droid  
##  3 R2-D2                 32 &lt;NA&gt;          white, blue Droid  
##  4 Darth Vader          136 none          white       Human  
##  5 Leia Organa           49 brown         light       Human  
##  6 Owen Lars            120 brown, grey   light       Human  
##  7 Beru Whitesun lars    75 brown         light       Human  
##  8 R5-D4                 32 &lt;NA&gt;          white, red  Droid  
##  9 Biggs Darklighter     84 black         light       Human  
## 10 Obi-Wan Kenobi        77 auburn, white fair        Human  
## # … with 77 more rows
```

---

# 3) dplyr::select

You can also rename your selected variables in place

```r
starwars |&gt;
  select(alias = name, crib = homeworld)
```

```
## # A tibble: 87 × 2
##    alias              crib    
##    &lt;chr&gt;              &lt;chr&gt;   
##  1 Luke Skywalker     Tatooine
##  2 C-3PO              Tatooine
##  3 R2-D2              Naboo   
##  4 Darth Vader        Tatooine
##  5 Leia Organa        Alderaan
##  6 Owen Lars          Tatooine
##  7 Beru Whitesun lars Tatooine
##  8 R5-D4              Tatooine
##  9 Biggs Darklighter  Tatooine
## 10 Obi-Wan Kenobi     Stewjon 
## # … with 77 more rows
```

---

# 3) dplyr::select

If you just want to rename columns without subsetting them, you can use `rename`:

```r
starwars |&gt;
  rename(alias = name, crib = homeworld)
```

```
## # A tibble: 87 × 14
##    alias    height  mass hair_color skin_color eye_color birth_year sex   gender
##    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
##  1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…
##  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu…
##  3 R2-D2        96    32 &lt;NA&gt;       white, bl… red             33   none  mascu…
##  4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
##  5 Leia Or…    150    49 brown      light      brown           19   fema… femin…
##  6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
##  7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…
##  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu…
##  9 Biggs D…    183    84 black      light      brown           24   male  mascu…
## 10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…
## # … with 77 more rows, and 5 more variables: crib &lt;chr&gt;, species &lt;chr&gt;,
## #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# 3) dplyr::select *cont.*

The `select(contains(PATTERN))` option provides a nice shortcut in relevant cases.

```r
starwars |&gt;
  select(name, contains("color"))
```

```
## # A tibble: 87 × 4
##    name               hair_color    skin_color  eye_color
##    &lt;chr&gt;              &lt;chr&gt;         &lt;chr&gt;       &lt;chr&gt;    
##  1 Luke Skywalker     blond         fair        blue     
##  2 C-3PO              &lt;NA&gt;          gold        yellow   
##  3 R2-D2              &lt;NA&gt;          white, blue red      
##  4 Darth Vader        none          white       yellow   
##  5 Leia Organa        brown         light       brown    
##  6 Owen Lars          brown, grey   light       blue     
##  7 Beru Whitesun lars brown         light       blue     
##  8 R5-D4              &lt;NA&gt;          white, red  red      
##  9 Biggs Darklighter  black         light       brown    
## 10 Obi-Wan Kenobi     auburn, white fair        blue-gray
## # … with 77 more rows
```

---

# 3) dplyr::select

The `select(..., everything())` option is another useful shortcut if you only want to bring some variable(s) to the "front" of a data frame


```r
starwars |&gt;
  select(species, homeworld, everything()) |&gt;
  head(5)
```

```
## # A tibble: 5 × 14
##   species homeworld name           height  mass hair_color skin_color  eye_color
##   &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;    
## 1 Human   Tatooine  Luke Skywalker    172    77 blond      fair        blue     
## 2 Droid   Tatooine  C-3PO             167    75 &lt;NA&gt;       gold        yellow   
## 3 Droid   Naboo     R2-D2              96    32 &lt;NA&gt;       white, blue red      
## 4 Human   Tatooine  Darth Vader       202   136 none       white       yellow   
## 5 Human   Alderaan  Leia Organa       150    49 brown      light       brown    
## # … with 6 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, gender &lt;chr&gt;,
## #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# 3) dplyr::select

You can also use `relocate` to do the same thing


```r
starwars |&gt;
  relocate(species, homeworld) |&gt;
  head(5)
```

```
## # A tibble: 5 × 14
##   species homeworld name           height  mass hair_color skin_color  eye_color
##   &lt;chr&gt;   &lt;chr&gt;     &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;    
## 1 Human   Tatooine  Luke Skywalker    172    77 blond      fair        blue     
## 2 Droid   Tatooine  C-3PO             167    75 &lt;NA&gt;       gold        yellow   
## 3 Droid   Naboo     R2-D2              96    32 &lt;NA&gt;       white, blue red      
## 4 Human   Tatooine  Darth Vader       202   136 none       white       yellow   
## 5 Human   Alderaan  Leia Organa       150    49 brown      light       brown    
## # … with 6 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, gender &lt;chr&gt;,
## #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# 4) dplyr::mutate

Why mutate?

--

You may need to create new variables

--

e.g. if I give you nominal house prices and the rate of house price inflation, you need to combine these two things to make a new .hi[real house price] variable

---

# 4) dplyr::mutate

You can create new columns from scratch as transformations of existing columns:

```r
starwars |&gt;
  select(name, birth_year) |&gt;
  mutate(dog_years = birth_year * 7) |&gt;
  mutate(comment = paste0(name, " is ", dog_years, " in dog years."))
```

```
## # A tibble: 87 × 4
##    name               birth_year dog_years comment                              
##    &lt;chr&gt;                   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                                
##  1 Luke Skywalker           19        133  Luke Skywalker is 133 in dog years.  
##  2 C-3PO                   112        784  C-3PO is 784 in dog years.           
##  3 R2-D2                    33        231  R2-D2 is 231 in dog years.           
##  4 Darth Vader              41.9      293. Darth Vader is 293.3 in dog years.   
##  5 Leia Organa              19        133  Leia Organa is 133 in dog years.     
##  6 Owen Lars                52        364  Owen Lars is 364 in dog years.       
##  7 Beru Whitesun lars       47        329  Beru Whitesun lars is 329 in dog yea…
##  8 R5-D4                    NA         NA  R5-D4 is NA in dog years.            
##  9 Biggs Darklighter        24        168  Biggs Darklighter is 168 in dog year…
## 10 Obi-Wan Kenobi           57        399  Obi-Wan Kenobi is 399 in dog years.  
## # … with 77 more rows
```

---


# 4) dplyr::mutate

*Note:* `mutate` creates variables in order, so you can chain multiple mutates in a single call

```r
starwars |&gt;
  select(name, birth_year) |&gt;
  mutate(
    dog_years = birth_year * 7, ## Separate with a comma
    comment = paste0(name, " is ", dog_years, " in dog years.")
  )
```

```
## # A tibble: 87 × 4
##    name               birth_year dog_years comment                              
##    &lt;chr&gt;                   &lt;dbl&gt;     &lt;dbl&gt; &lt;chr&gt;                                
##  1 Luke Skywalker           19        133  Luke Skywalker is 133 in dog years.  
##  2 C-3PO                   112        784  C-3PO is 784 in dog years.           
##  3 R2-D2                    33        231  R2-D2 is 231 in dog years.           
##  4 Darth Vader              41.9      293. Darth Vader is 293.3 in dog years.   
##  5 Leia Organa              19        133  Leia Organa is 133 in dog years.     
##  6 Owen Lars                52        364  Owen Lars is 364 in dog years.       
##  7 Beru Whitesun lars       47        329  Beru Whitesun lars is 329 in dog yea…
##  8 R5-D4                    NA         NA  R5-D4 is NA in dog years.            
##  9 Biggs Darklighter        24        168  Biggs Darklighter is 168 in dog year…
## 10 Obi-Wan Kenobi           57        399  Obi-Wan Kenobi is 399 in dog years.  
## # … with 77 more rows
```

---

# 4) dplyr::mutate

Boolean, logical and conditional operators all work well with `mutate` too:

```r
starwars |&gt;
  select(name, height) |&gt;
  filter(name %in% c("Luke Skywalker", "Anakin Skywalker")) |&gt;
  mutate(tall1 = height &gt; 180) |&gt; # TRUE or FALSE
  mutate(tall2 = ifelse(height &gt; 180, "Tall", "Short")) ## Same effect, but can choose labels
```

```
## # A tibble: 2 × 4
##   name             height tall1 tall2
##   &lt;chr&gt;             &lt;int&gt; &lt;lgl&gt; &lt;chr&gt;
## 1 Luke Skywalker      172 FALSE Short
## 2 Anakin Skywalker    188 TRUE  Tall
```

---

# 4) dplyr::mutate

Lastly, combining `mutate` with `across` allows you to easily work on a subset of variables:

```r
starwars |&gt;
  select(name:eye_color) |&gt;
  mutate(across(where(is.character), toupper)) |&gt; # Take all character variables, uppercase them
  head(5)
```

```
## # A tibble: 5 × 6
##   name           height  mass hair_color skin_color  eye_color
##   &lt;chr&gt;           &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt;    
## 1 LUKE SKYWALKER    172    77 BLOND      FAIR        BLUE     
## 2 C-3PO             167    75 &lt;NA&gt;       GOLD        YELLOW   
## 3 R2-D2              96    32 &lt;NA&gt;       WHITE, BLUE RED      
## 4 DARTH VADER       202   136 NONE       WHITE       YELLOW   
## 5 LEIA ORGANA       150    49 BROWN      LIGHT       BROWN
```

---

# 5) dplyr::summarise

Why summarise?

--

Often we want to get summary statistics or *collapse* our data

--

e.g. if I gave you a data set of each individual's marginal damage in the US, we may want to aggregate up to county-level marginal damages

---

# 5) dplyr::summarise

Summarising useful in combination with the `group_by` command

```r
starwars |&gt;
  group_by(species, gender) |&gt; # for each species-gender combo
  summarise(mean_height = mean(height, na.rm = TRUE)) # calculate the mean height
```

```
## `summarise()` has grouped output by 'species'. You can override using the
## `.groups` argument.
```

```
## # A tibble: 42 × 3
## # Groups:   species [38]
##    species   gender    mean_height
##    &lt;chr&gt;     &lt;chr&gt;           &lt;dbl&gt;
##  1 Aleena    masculine          79
##  2 Besalisk  masculine         198
##  3 Cerean    masculine         198
##  4 Chagrian  masculine         196
##  5 Clawdite  feminine          168
##  6 Droid     feminine           96
##  7 Droid     masculine         140
##  8 Dug       masculine         112
##  9 Ewok      masculine          88
## 10 Geonosian masculine         183
## # … with 32 more rows
```

---

# 5) dplyr::summarise

Note that including "na.rm = TRUE" is usually a good idea with summarise functions, it keeps NAs from propagating to the end result

```r
## Probably not what we want
starwars |&gt;
  summarise(mean_height = mean(height))
```

```
## # A tibble: 1 × 1
##   mean_height
##         &lt;dbl&gt;
## 1          NA
```

---

# 5) dplyr::summarise

We can also use `across` within summarise:

```r
starwars |&gt;
group_by(species) |&gt; # for each species
summarise(across(where(is.numeric), mean, na.rm = T)) |&gt; # take the mean of all numeric variables
head(5)
```

```
## # A tibble: 5 × 4
##   species  height  mass birth_year
##   &lt;chr&gt;     &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;
## 1 Aleena       79    15        NaN
## 2 Besalisk    198   102        NaN
## 3 Cerean      198    82         92
## 4 Chagrian    196   NaN        NaN
## 5 Clawdite    168    55        NaN
```

---

# Other dplyr goodies

`group_by` and `ungroup`: For (un)grouping
- Particularly useful with the `summarise` and `mutate` commands

--

`slice`: Subset rows by position rather than filtering by values
- E.g. `starwars |&gt; slice(c(1, 5))`

---

# Other dplyr goodies

`pull`: Extract a column from as a data frame as a vector or scalar
- E.g. `starwars |&gt; filter(gender=="female") |&gt; pull(height)`

--

`count` and `distinct`: Number and isolate unique observations
- E.g. `starwars |&gt; count(species)`, or `starwars |&gt; distinct(species)`


---

# Other dplyr goodies

There are also a whole class of [window functions](https://cran.r-project.org/web/packages/dplyr/vignettes/window-functions.html) for getting leads and lags, percentiles, cumulative sums, etc.
- See `vignette("window-functions")`.

---

# dplyr::xxxx_join

The last set of commands we need are the `join` commands

--

These are the same as `merge` in stata but with a bit more functionality

--

Why join?

--

Suppose we want to understand how pollution affects housing prices

--

You may need to combine data sets: one data sets on house prices in all counties, and another data set on pollution levels in all counties

---

# dplyr::xxxx_join

How does joining work?

--

We need two datasets (e.g. housing prices and pollution)

--

Each dataset has the same set of .hi[key] variables (e.g. county)

--

When we join, we match up the two datasets on the key, and combine them into one

--

In our housing example, each row of the joined dataset would now tell us the house price, the county its in, and the county's pollution
                                                        

---
  
# dplyr::xxxx_join
  
We merge data with [join operations](https://cran.r-project.org/web/packages/dplyr/vignettes/two-table.html):
- `inner_join(df1, df2)`
- `left_join(df1, df2)`
- `right_join(df1, df2)`
- `full_join(df1, df2)`

(You can visualize the operations [here](https://r4ds.had.co.nz/relational-data.html))

---
  
# dplyr::xxxx_join
  
Lets use the data that comes with the the [nycflights13](http://github.com/hadley/nycflights13) package.


```r
library(nycflights13)
flights
```

```
## # A tibble: 336,776 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # … with 336,766 more rows, and 11 more variables: arr_delay &lt;dbl&gt;,
## #   carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;
```

---
  
# dplyr::xxxx_join
  

```r
planes
```

```
## # A tibble: 3,322 × 9
##    tailnum  year type              manufacturer model engines seats speed engine
##    &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 
##  1 N10156   2004 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…
##  2 N102UW   1998 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  3 N103US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  4 N104UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  5 N10575   2002 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…
##  6 N105UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  7 N107US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  8 N108UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  9 N109UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
## 10 N110UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
## # … with 3,312 more rows
```

---
  
# Joining operations
  
Let's perform a left join on the flights and planes datasets
- *Note*: I'm going subset columns after the join, but only to keep text on the slide

--
  

```r
left_join(flights, planes) |&gt;
  select(year, month, day, dep_time, arr_time, carrier, flight, tailnum, type, model)
```

```
## Joining, by = c("year", "tailnum")
```

```
## # A tibble: 336,776 × 10
##     year month   day dep_time arr_time carrier flight tailnum type  model
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;
##  1  2013     1     1      517      830 UA        1545 N14228  &lt;NA&gt;  &lt;NA&gt; 
##  2  2013     1     1      533      850 UA        1714 N24211  &lt;NA&gt;  &lt;NA&gt; 
##  3  2013     1     1      542      923 AA        1141 N619AA  &lt;NA&gt;  &lt;NA&gt; 
##  4  2013     1     1      544     1004 B6         725 N804JB  &lt;NA&gt;  &lt;NA&gt; 
##  5  2013     1     1      554      812 DL         461 N668DN  &lt;NA&gt;  &lt;NA&gt; 
##  6  2013     1     1      554      740 UA        1696 N39463  &lt;NA&gt;  &lt;NA&gt; 
##  7  2013     1     1      555      913 B6         507 N516JB  &lt;NA&gt;  &lt;NA&gt; 
##  8  2013     1     1      557      709 EV        5708 N829AS  &lt;NA&gt;  &lt;NA&gt; 
##  9  2013     1     1      557      838 B6          79 N593JB  &lt;NA&gt;  &lt;NA&gt; 
## 10  2013     1     1      558      753 AA         301 N3ALAA  &lt;NA&gt;  &lt;NA&gt; 
## # … with 336,766 more rows
```

---
  
# Joining operations

Note that dplyr made a reasonable guess about which columns to join on (i.e. columns that share the same name), and told us what it chose
```
*## Joining, by = c("year", "tailnum")
  ```

There's an obvious problem here: the variable `year` does not have a consistent meaning across our joining datasets

--

In one it refers to the *year of flight*, in the other it refers to *year of construction*

Luckily, there's an easy way to avoid this problem: try `?dplyr::join`

---
  
# Joining operations

You just need to be more explicit in your join call by using the `by = ` argument

```r
left_join(
  flights,
  planes |&gt; rename(year_built = year), ## Not necessary w/ below line, but helpful
  by = "tailnum" ## Be specific about the joining column
) |&gt;
  select(year, month, day, dep_time, arr_time, carrier, flight, tailnum, year_built, type, model) |&gt;
  head(3) ## Just to save vertical space on the slide
```

```
## # A tibble: 3 × 11
##    year month   day dep_time arr_time carrier flight tailnum year_built type    
##   &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;        &lt;int&gt; &lt;chr&gt;   
## 1  2013     1     1      517      830 UA        1545 N14228        1999 Fixed w…
## 2  2013     1     1      533      850 UA        1714 N24211        1998 Fixed w…
## 3  2013     1     1      542      923 AA        1141 N619AA        1990 Fixed w…
## # … with 1 more variable: model &lt;chr&gt;
```

---

# Joining operations

Note what happens if we again specify the join column but don't rename the ambiguous `year`:

```r
left_join(flights,
planes, ## Not renaming "year" to "year_built" this time
by = "tailnum") |&gt;
select(contains("year"), month, day, dep_time, arr_time, carrier, flight, tailnum, type, model) |&gt;
head(3)
```

```
## # A tibble: 3 × 11
##   year.x year.y month   day dep_time arr_time carrier flight tailnum type  model
##    &lt;int&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;    &lt;int&gt; &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;
## 1   2013   1999     1     1      517      830 UA        1545 N14228  Fixe… 737-…
## 2   2013   1998     1     1      533      850 UA        1714 N24211  Fixe… 737-…
## 3   2013   1990     1     1      542      923 AA        1141 N619AA  Fixe… 757-…
```

--

Make sure you know what "year.x" and "year.y" are

---
class: inverse, center, middle
name: tidyr

# tidyr

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# Key tidyr verbs

1. `pivot_longer`: Pivot wide data into long format (i.e. "melt", "reshape long")

2. `pivot_wider`: Pivot long data into wide format (i.e. "cast", "reshape wide")

3. `separate`: Split one column into multiple columns

4. `unite`: Combine multiple columns into one

--

Let's practice these verbs together in class

---

# 1) tidyr::pivot_longer


```r
stocks = data.frame(
time = as.Date('2009-01-01') + 0:1,
stock_X = rnorm(2, 0, 1),
stock_Y = rnorm(2, 0, 2),
stock_Z = rnorm(2, 0, 4)
)
stocks
```

```
##         time    stock_X   stock_Y  stock_Z
## 1 2009-01-01 -1.2748637 0.5036504 -7.56014
## 2 2009-01-02  0.4597851 0.2333985 -2.14677
```

We have 4 variables, the date and the stocks

How do we get this in tidy form?

---

# 1) tidyr::pivot_longer


```r
stocks |&gt; pivot_longer(-time, names_to = "stock", values_to = "price")
```

We need to pivot the stock name variables `X, Y, Z` longer

1. Choose non-time variables: `-time`
2. Decide what variable holds the names: `names_to = "stock"`
3. Decide what variable holds the values: `values_to = "price"`

---

# 1) tidyr::pivot_longer


```r
stocks |&gt; pivot_longer(-time, names_to = "stock", values_to = "price")
```

```
## # A tibble: 6 × 3
##   time       stock    price
##   &lt;date&gt;     &lt;chr&gt;    &lt;dbl&gt;
## 1 2009-01-01 stock_X -1.27 
## 2 2009-01-01 stock_Y  0.504
## 3 2009-01-01 stock_Z -7.56 
## 4 2009-01-02 stock_X  0.460
## 5 2009-01-02 stock_Y  0.233
## 6 2009-01-02 stock_Z -2.15
```

---

# 1) tidyr::pivot_longer

Let's quickly save the "tidy" (i.e. long) stocks data frame for use on the next slide


```r
tidy_stocks = stocks |&gt;
  pivot_longer(-time, names_to = "stock", values_to = "price")
```

---
  
  # 2) tidyr::pivot_wider
  

```r
tidy_stocks |&gt; pivot_wider(names_from = stock, values_from = price)
```

```
## # A tibble: 2 × 4
##   time       stock_X stock_Y stock_Z
##   &lt;date&gt;       &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
## 1 2009-01-01  -1.27    0.504   -7.56
## 2 2009-01-02   0.460   0.233   -2.15
```

```r
tidy_stocks |&gt; pivot_wider(names_from = time, values_from = price)
```

```
## # A tibble: 3 × 3
##   stock   `2009-01-01` `2009-01-02`
##   &lt;chr&gt;          &lt;dbl&gt;        &lt;dbl&gt;
## 1 stock_X       -1.27         0.460
## 2 stock_Y        0.504        0.233
## 3 stock_Z       -7.56        -2.15
```

--
  
  Note that the second example has effectively transposed the data
---
  
  # 3) tidyr::separate
  

```r
economists = data.frame(name = c("Adam.Smith", "Paul.Samuelson", "Milton.Friedman"))
economists
```

```
##              name
## 1      Adam.Smith
## 2  Paul.Samuelson
## 3 Milton.Friedman
```

```r
economists |&gt; separate(name, c("first_name", "last_name"))
```

```
##   first_name last_name
## 1       Adam     Smith
## 2       Paul Samuelson
## 3     Milton  Friedman
```

--
  
This command is pretty smart. But to avoid ambiguity, you can also specify the separation character with `separate(..., sep=".")`

---
  
  # 4) tidyr::unite
  

```r
gdp = data.frame(
  yr = rep(2016, times = 4),
  mnth = rep(1, times = 4),
  dy = 1:4,
  gdp = rnorm(4, mean = 100, sd = 2)
)
gdp
```

```
##     yr mnth dy       gdp
## 1 2016    1  1 102.16210
## 2 2016    1  2  98.96899
## 3 2016    1  3  99.70125
## 4 2016    1  4 100.25458
```

---
  
  # 4) tidyr::unite
  

```r
## Combine "yr", "mnth", and "dy" into one "date" column
gdp |&gt; unite(date, c("yr", "mnth", "dy"), sep = "-")
```

```
##       date       gdp
## 1 2016-1-1 102.16210
## 2 2016-1-2  98.96899
## 3 2016-1-3  99.70125
## 4 2016-1-4 100.25458
```

---
  
# 4) tidyr::unite
  
Note that `unite` will automatically create a character variable:

```r
gdp_u = gdp |&gt; unite(date, c("yr", "mnth", "dy"), sep = "-") |&gt; as_tibble()
gdp_u
```

```
## # A tibble: 4 × 2
##   date       gdp
##   &lt;chr&gt;    &lt;dbl&gt;
## 1 2016-1-1 102. 
## 2 2016-1-2  99.0
## 3 2016-1-3  99.7
## 4 2016-1-4 100.
```

--
  
If you want to convert it to something else (e.g. date or numeric) then you will need to modify it using `mutate`

---

# 4) tidyr::unite


```r
library(lubridate)
gdp_u |&gt; mutate(date = ymd(date))
```

```
## # A tibble: 4 × 2
##   date         gdp
##   &lt;date&gt;     &lt;dbl&gt;
## 1 2016-01-01 102. 
## 2 2016-01-02  99.0
## 3 2016-01-03  99.7
## 4 2016-01-04 100.
```


---
  
class: inverse, center, middle
name: tidyverse

# Regression and ordinary least squares

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---

# Why?

## Motivation

Let's start with a few .hi[basic, general questions]

--

1. What is the goal of econometrics?

2. Why do economists (or other people) study or use econometrics?

--

.hi[One simple answer:] Learn about the world using data


---

# Why? Example

GPA is an output from endowments (ability), and hours studied (inputs), and pollution exposure (externality)

--

One might hypothesize a model:
`\(\text{GPA}=f(I, P, \text{SAT}, H)\)`

where `\(H\)` is hours studied, `\(P\)` is pollution exposure, `\(\text{SAT}\)` is SAT score and `\(\text{I}\)` is family income

--

We expect that GPA will rise with some variables, and decrease with others

--

But who needs to _expect_?

--

We can test these hypotheses .hi[using a regression model]

---

# How?

We can write down a linear regression model of the relationship between GPA and (H, P, SAT, PCT):
$$ \text{GPA}_i = \beta_0 + \beta_1 I_i + \beta_2 P_i + \beta_3 \text{SAT}_i + \beta_4 H_i + \varepsilon_i $$

--

The left hand side of the equals sign is our .hi-blue[dependent variable] GPA

--

The right hand side of the equals sign contains all of our .hi-red[independent variables] (I, P, SAT, H), and an error term `\(\varepsilon_i\)` (described later)

--

The subscript `\(i\)` means that the variable contains the value for some person `\(i\)` in our dataset where `\(i = 1,\dots,N\)`

---

# How?

$$ \text{GPA}_i = \beta_0 + \beta_1 I_i + \beta_2 P_i + \beta_3 \text{SAT}_i + \beta_4 H_i + \varepsilon_i $$

We are interested in how pollution P affects GPA

--

This is given by `\(\beta_2\)`

--

Notice that `\(\beta_2 = \frac{\partial\text{GPA}_i}{\partial\text{P}_i}\)`

--

`\(\beta_2\)` tells us how GPA changes, given a 1 unit increase in pollution!

--

Our goal will be to estimate `\(\beta_2\)`, we denote estimates with hats: `\(\hat{\beta}_2\)`


---

# How?

How do we estimate `\(\beta_2\)`?

--

First, suppose we have a set of estimates for all of our `\(\beta\)`s, then we can *estimate* the GPA `\((\widehat{GPA}_i)\)` for any given person based on just (I, P, SAT, H):
`$$\widehat{GPA}_i = \hat{\beta}_0 + \hat{\beta}_1 I_i + \hat{\beta}_2 P_i + \hat{\beta}_3 \text{SAT}_i + \hat{\beta}_4 H_i$$`

---

# How?

We estimate the `\(\beta\)`s with .hi[linear regression], specifically ordinary least squares

.hi[Ordinary least squares:] choose all the `\(\beta\)`s so that the sum of squared errors between the *real* GPAs and model-estimated GPAs are minimized:
`$$SSE = \sum_{i=1}^N (GPA_i - \widehat{GPA}_i)^2$$`

--

Choosing the `\(\beta\)`s in this fashion gives us the best-fit line through the data

---

# How?




---

# Simple example

Suppose we were only looking at GPA and pollution (lead/Pb):

$$\text{GPA}_i = \beta_0 + \beta_1 P_i + \varepsilon_i $$

![](10-slides-r_files/figure-html/ols vs lines 1-1.svg)&lt;!-- --&gt;

---
count: false
# Simple example


For any line `\(\left(\hat{GPA}_i = \hat{\beta}_0 + \hat{\beta}_1 P_i\right)\)`

![](10-slides-r_files/figure-html/vs lines 2-1.svg)&lt;!-- --&gt;

---
count: false
# Simple example


For any line `\(\left(\hat{GPA}_i = \hat{\beta}_0 + \hat{\beta}_1 P_i\right)\)`, we calculate errors: `\(e_i = GPA_i - \hat{GPA}_i\)`

![](10-slides-r_files/figure-html/ols vs lines 3-1.svg)&lt;!-- --&gt;

---
count: false
# Simple example


For any line `\(\left(\hat{GPA}_i = \hat{\beta}_0 + \hat{\beta}_1 P_i\right)\)`, we calculate errors: `\(e_i = GPA_i - \hat{GPA}_i\)`

![](10-slides-r_files/figure-html/ols vs lines 4-1.svg)&lt;!-- --&gt;

---
count: false
# Simple example


For any line `\(\left(\hat{GPA}_i = \hat{\beta}_0 + \hat{\beta}_1 P_i\right)\)`, we calculate errors: `\(e_i = GPA_i - \hat{GPA}_i\)`

![](10-slides-r_files/figure-html/ols vs lines 5-1.svg)&lt;!-- --&gt;

---
count: false
# Simple example


SSE squares the errors `\(\left(\sum e_i^2\right)\)`: bigger errors get bigger penalties

![](10-slides-r_files/figure-html/ols vs lines 6-1.svg)&lt;!-- --&gt;

---
count: false
# Simple example


The OLS estimate is the combination of `\(\hat{\beta}_0\)` and `\(\hat{\beta}_1\)` that minimize SSE

![](10-slides-r_files/figure-html/ols vs lines 7-1.svg)&lt;!-- --&gt;

---

# OLS error term

So OLS is just the best-fit line through your data

--

Remember: for any given `\(i\)`, we won't have that `\(GPA_i = \widehat{GPA}_i\)`, there's always some error

--

Why?

--

Our model isn't perfect, the people in our dataset (i.e. our sample) may not perfectly match up to the entire population of people

---

# OLS error term

There's .hi[a lot] of other stuff that determines GPAs!

--

We jam all that stuff into error term `\(\varepsilon_i\)`:
$$ \text{GPA}_i = \beta_0 + \beta_1 I_i + \beta_2 P_i + \beta_3 \text{SAT}_i + \beta_4 H_i + \varepsilon_i $$

--

So `\(\varepsilon_i\)` contains all the determinants of GPA that we aren't explicitly addressing in our model

---

# OLS properties

OLS has one .hi[very] nice property relevant for this class:

--

&lt;center&gt;
.hi-blue[Unbiasedness:] `\(E[\hat{\beta}] = \beta\)`
&lt;/center&gt;
---

# OLS properties

.hi-blue[Unbiasedness:] `\(E[\hat{\beta}] = \beta\)`

On average, our estimate `\(\hat{\beta}\)` exactly equals the .hi[true] `\(\beta\)`

--

The key is .hi-red[on average:] we are estimating our model using only some sample of the data

--

The estimated `\(\beta\)` won't exactly be right for the entire population, but on average, we expect it to match

--

Let's see in an example where we only have a subsample of the full population of data

---

# OLS properties


.pull-left[

&lt;img src="10-slides-r_files/figure-html/pop1-1.svg" style="display: block; margin: auto;" /&gt;

.center[**Population**]

]

--

.pull-right[

&lt;img src="10-slides-r_files/figure-html/scatter1-1.svg" style="display: block; margin: auto;" /&gt;

.center[**Population relationship**]

$$ y_i = 2.53 + -0.43 x_i + u_i $$

$$ y_i = \beta_0 + \beta_1 x_i + u_i $$


]

---

.pull-left[


&lt;img src="10-slides-r_files/figure-html/sample1-1.svg" style="display: block; margin: auto;" /&gt;

.center[**Sample 1:** 10 random individuals]


]

--

.pull-right[


&lt;img src="10-slides-r_files/figure-html/sample1 scatter-1.svg" style="display: block; margin: auto;" /&gt;


.center[

**Population relationship**
&lt;br&gt;
`\(y_i = 2.53 + -0.43 x_i + u_i\)`

**Sample relationship**
&lt;br&gt;
`\(\hat{y}_i = 0.72 + -0.19 x_i\)`

]

]

---
count: false

.pull-left[

&lt;img src="10-slides-r_files/figure-html/sample2-1.svg" style="display: block; margin: auto;" /&gt;

.center[**Sample 2:** 10 random individuals]

]

.pull-right[

&lt;img src="10-slides-r_files/figure-html/sample2 scatter-1.svg" style="display: block; margin: auto;" /&gt;

.center[

**Population relationship**
&lt;br&gt;
`\(y_i = 2.53 + -0.43 x_i + u_i\)`

**Sample relationship**
&lt;br&gt;
`\(\hat{y}_i = 2.82 + -0.47 x_i\)`

]

]
---
count: false

.pull-left[

&lt;img src="10-slides-r_files/figure-html/sample3-1.svg" style="display: block; margin: auto;" /&gt;

.center[**Sample 3:** 10 random individuals]

]

.pull-right[

&lt;img src="10-slides-r_files/figure-html/sample3 scatter-1.svg" style="display: block; margin: auto;" /&gt;

.center[

**Population relationship**
&lt;br&gt;
`\(y_i = 2.53 + -0.43 x_i + u_i\)`

**Sample relationship**
&lt;br&gt;
`\(\hat{y}_i = 2.32 + -0.44 x_i\)`

]

]

---
layout: false
class: clear, middle

Let's repeat this **1,000 times**.

(This exercise is called a (Monte Carlo) simulation.)

---

# Population *vs.* sample

![](10-slides-r_files/figure-html/simulation scatter-1.png)&lt;!-- --&gt;

---

# Population *vs.* sample

**Question:** Why do we care about *population vs. sample*?

---

.pull-left[ 
  ![](10-slides-r_files/figure-html/unnamed-chunk-44-1.png)&lt;!-- --&gt;
]

.pull-right[

On .hi-blue[average], our regression lines match the population line very nicely

However, .hi[individual lines] (samples) can really miss the mark

Differences between individual samples and the population lead to **uncertainty** for us in the true effect

]

---

# Population *vs.* sample

**Answer:** Uncertainty matters!

--

`\(\hat{\beta}\)` itself is random, it will depend on the sample of data we have

--

When we take a sample and run a regression, we don't know if it's a 'good' sample ( `\(\hat{\beta}\)` is close to `\(\beta\)`) or a 'bad sample' (our sample differs greatly from the population)

---

# Unbiasedness

For OLS to be unbiased and give us, on average, the causal effect of some X on some Y we need a few assumptions to hold

--

Whether or not these assumptions are true is why you often hear *correlation is not causation*

--

If we want some `\(\hat{\beta}_1\)` on a variable `\(x\)` to be unbiased we need the following to be true:
`$$E[x \varepsilon] = 0 \quad \leftrightarrow \quad \text{correlation}(x,\varepsilon) = 0$$`

--

The variable you are interested in .hi[cannot] be correlated with the error term

---

# Unbiasedness

The variable you are interested in .hi[cannot] be correlated with the error term

--

What does this mean in words?

--

The error term contains all variables that determine `\(y\)`, but we *omitted* from our model

--

We are assuming that our variable of interest, x, is not correlated with any of these omitted variable

--

If x is correlated with any of them, then we will have something called .hi[omitted variable bias]

---

# Omitted variable bias

Here's an intuitive example

--

Suppose we wanted to understand the effect of lead exposure `\(P\)` on GPAs

--

lead harm's children's brain development, especially before age 6

--

We should expect early-life lead exposure to reduce future GPAs

---

# Omitted variable bias

Our model might look like:
`$$\text{GPA}_i = \beta_0 + \beta_1 \text{P}_i + \varepsilon_i$$`

--

We want to know `\(\beta_1\)`

--

What would happen if we took a sample of *real world data* and used OLS to estimate `\(\hat{\beta}_1\)`?

---

# Omitted variable bias

We would have omitted variable bias

--

Why? What are some examples?

--

.hi[Who] is more likely to be exposed to lead?

--

Poorer families likely have more lead exposure, why?

--

Richer families can move away, pay to replace lead paint, lead pipes, etc

--

This means lead exposure is correlated with lower income

---

# Omitted variable bias

Why does this correlation cause us problems?

--

Family income *also* matters for GPA, it is in `\(\varepsilon_i\)`, so our assumption that `\(\text{correlation}(x,\varepsilon) = 0\)` is violated

--

Children from richer families tend to have higher GPAs

--

Why?

--

Access to tutoring, better schools, parental pressure, etc, etc

---

# Omitted variable bias

If we just look at the effect of lead exposure on GPAs without addressing its correlation with income, lead exposure will look worse than it actually is

--

This is because our data on lead exposure is also proxying for income (since `\(\text{correlation}(x,\varepsilon) = 0\)` )

--

So `\(\hat{\beta}_1\)` will pick up the effect of both!

--

Our estimate `\(\hat{\beta}_1\)` is .hi[biased] and overstates the negative effects of lead

---

# Omitted variable bias

How do we fix this bias?

--

Make income not omitted: control for it in our model

--

If we have data on family income `\(I\)` we can instead write our model as:
`$$\text{GPA}_i = \beta_0 + \beta_1 \text{P}_i + \beta_2 \text{I}_i + \varepsilon_i$$`

`\(I\)` is no longer omitted

--

Independent variables in our model that we include to address bias are called .hi[controls]

---

class: inverse, center, middle
name: reg_in_r

# Regression in R

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;

---

# How do we actually run regressions?

Now we are going to learn how to run regressions in R

--

There's a lot of regression packages, built-in is `lm`, or you can also use a new one called `fixest`

--

We will also be using the `broom` package to make our output look nice

--

They work almost identically


---

# Using regression packages


To run a regression we need 3 things:

--

1. The package that will run the regression
2. Our regression formula
3. The dataframe that contains our data

--

In general, we will always run a regression like this: `package_name(formula_here, data = dataframe_here)`

--

You can then store the output by assigning it to a variable: `results = package_name(formula_here, data = dataframe_here)`

---

# Using regression packages

Let's start by using the built-in `lm` package along with the `starwars` dataset


```r
starwars
```

```
## # A tibble: 87 × 14
##    name     height  mass hair_color skin_color eye_color birth_year sex   gender
##    &lt;chr&gt;     &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;          &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
##  1 Luke Sk…    172    77 blond      fair       blue            19   male  mascu…
##  2 C-3PO       167    75 &lt;NA&gt;       gold       yellow         112   none  mascu…
##  3 R2-D2        96    32 &lt;NA&gt;       white, bl… red             33   none  mascu…
##  4 Darth V…    202   136 none       white      yellow          41.9 male  mascu…
##  5 Leia Or…    150    49 brown      light      brown           19   fema… femin…
##  6 Owen La…    178   120 brown, gr… light      blue            52   male  mascu…
##  7 Beru Wh…    165    75 brown      light      blue            47   fema… femin…
##  8 R5-D4        97    32 &lt;NA&gt;       white, red red             NA   none  mascu…
##  9 Biggs D…    183    84 black      light      brown           24   male  mascu…
## 10 Obi-Wan…    182    77 auburn, w… fair       blue-gray       57   male  mascu…
## # … with 77 more rows, and 5 more variables: homeworld &lt;chr&gt;, species &lt;chr&gt;,
## #   films &lt;list&gt;, vehicles &lt;list&gt;, starships &lt;list&gt;
```

---

# Using regression packages

Suppose we wanted to see what was the effect of height on mass:
$$ mass_i = \beta_0 + \beta_1 height_i + \varepsilon_i $$

---

# Using regression packages

Before we begin lets look at the data and see what the relationship looks like:
.center[
  ![](10-slides-r_files/figure-html/unnamed-chunk-46-1.svg)&lt;!-- --&gt;
]

Looks like there's an outlier!


---

# Using regression packages

What if we plot it in log units?
.center[
![](10-slides-r_files/figure-html/unnamed-chunk-47-1.svg)&lt;!-- --&gt;
]

That dampens the outlier, the positive association is really clear!


---

# Using regression packages

What if we plot it in log units?
.center[
![](10-slides-r_files/figure-html/unnamed-chunk-48-1.svg)&lt;!-- --&gt;
]

Here's the best fit line, now let's actually estimate `\(\beta_0, \beta_1\)`


---

# Using regression packages

First we need to construct our formula

--

We do this like: `dependent variable ~ independent variable 1 + independent variable 2 + ... + independent variable N`

--

For this example we would write: `mass ~ height`

---

# Using regression packages

$$ mass_i = \beta_0 + \beta_1 height_i + \varepsilon_i $$

We can run the following code:


```r
# package_name(formula_here, data = dataframe_here)
lm(mass ~ height, data = starwars)
```

```
## 
## Call:
## lm(formula = mass ~ height, data = starwars)
## 
## Coefficients:
## (Intercept)       height  
##    -13.8103       0.6386
```

This gives us the coefficient estimate `\(\hat{\beta}_0\)` (intercept), and `\(\hat{\beta}_1\)` (height)

---

# Using regression packages

We can clean up the output a bit and get other statistics by piping it to `broom::tidy`:


```r
# package_name(formula_here, data = dataframe_here)
lm(mass ~ height, data = starwars) |&gt;
broom::tidy()
```

```
## # A tibble: 2 × 5
##   term        estimate std.error statistic p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
## 1 (Intercept)  -13.8     111.       -0.124   0.902
## 2 height         0.639     0.626     1.02    0.312
```

The coefficient estimates are now in column `estimates`, and we have a few other things

---

# Using regression packages



The first column gives us our estimates: `\(\hat{\beta_0}, \hat{\beta}_1\)`

--

The last column is the .hi[p-value]: the probability that we would have gotten an estimate at least that large, if the *true* value was actually 0

--

Smaller values generally mean it is more likely that height has an effect on mass: the probability that we could have gotten our estimated value if height didn't matter is very low

--

Alternatively: smaller values mean it is more likely that we can reject that `\(\beta_1 = 0\)`
  

---

# Interpreting coefficient estimates


```
## # A tibble: 2 × 5
##   term        estimate std.error statistic p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
## 1 (Intercept)  -13.8     111.       -0.124   0.902
## 2 height         0.639     0.626     1.02    0.312
```

What do these coefficient estimates mean?

--

The estimate for the `\(\beta\)` on height means: people who are 1cm taller tend to be 0.639kg heavier

--

This just comes from our previous example where `\(\beta_1 = \frac{\partial mass_i}{\partial height_i}\)`

---

# Interpreting coefficient estimates


```
## # A tibble: 2 × 5
##   term        estimate std.error statistic p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
## 1 (Intercept)  -13.8     111.       -0.124   0.902
## 2 height         0.639     0.626     1.02    0.312
```

How do we interpret `\(\beta_0\)`, the estimate of the *intercept*?

--

Well, it is just the estimated mass, given someone had zero height:
`$$\hat{\beta}_0 = \hat{\beta}_0 + \hat{\beta}_1 \times 0$$`

--

It's kind of a nonsense interpretation here since no one has zero height

--

Generally we don't read too much into the intercept terms

---

# Interpreting coefficient estimates

Now, what if we changed our model a bit so it was instead:
`$$\log(\text{mass}_i) = \beta_0 + \beta_1 \log(\text{height}_i) + \varepsilon_i$$`

What does `\(\beta_1\)` mean now?

--

`$$\beta_1 = \frac{\partial \log(\text{mass}_i)}{\partial \log(\text{height}_i)}$$`

--

But we can rewrite this as:
`$$\beta_1 = \frac{\partial \log(\text{mass}_i)}{\partial \log(\text{height}_i)} = \frac{\partial \log(\text{mass}_i)}{\partial \text{mass}_i}\frac{\partial \text{mass}_i}{\partial \text{height}_i}\frac{\partial \text{height}_i}{\partial \log(\text{height}_i)}$$`

---

# Interpreting coefficient estimates

`$$\beta_1 = \frac{\partial \log(\text{mass}_i)}{\partial \log(\text{height}_i)} = \frac{\partial \log(\text{mass}_i)}{\partial \text{mass}_i}\frac{\partial \text{mass}_i}{\partial \text{height}_i}\frac{\partial \text{height}_i}{\partial \log(\text{height}_i)}$$`

And this is equal to:
`$$\beta_1 = \frac{\partial \log(\text{mass}_i)}{\partial \log(\text{height}_i)} = \frac{1}{\text{mass}_i}\frac{\partial \text{mass}_i}{\partial \text{height}_i}\frac{\text{height}_i}{1}$$`

--

And finally:
`$$\beta_1 = \frac{\partial \log(\text{mass}_i)}{\partial \log(\text{height}_i)} = \frac{\text{height}_i}{\text{mass}_i}\frac{\partial \text{mass}_i}{\partial \text{height}_i}$$`

which is the definition of the elasticity of mass with respect to height

---

# Interpreting coefficient estimates

`$$\log(\text{mass}_i) = \beta_0 + \beta_1 \log(\text{height}_i) + \varepsilon_i$$`

In a *log-log* model, `\(\beta_1\)` tells us the percent change in mass, given a percent change in height

--
  
Let's run the regression:


```r
# package_name(formula_here, data = dataframe_here)
lm(log(mass) ~ log(height), data = starwars) |&gt;
broom::tidy()
```

```
## # A tibble: 2 × 5
##   term        estimate std.error statistic       p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;         &lt;dbl&gt;
## 1 (Intercept)    -3.84     1.17      -3.27 0.00181      
## 2 log(height)     1.58     0.228      6.93 0.00000000410
```

---

# Interpreting coefficient estimates


```r
# package_name(formula_here, data = dataframe_here)
lm(log(mass) ~ log(height), data = starwars) |&gt;
broom::tidy()
```

```
## # A tibble: 2 × 5
##   term        estimate std.error statistic       p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;         &lt;dbl&gt;
## 1 (Intercept)    -3.84     1.17      -3.27 0.00181      
## 2 log(height)     1.58     0.228      6.93 0.00000000410
```

A 1% increase in height is associated with a 1.58% increase in mass!


---

class: inverse, center, middle
name: r

# Hands-on pollution education example

&lt;html&gt;&lt;div style='float:left'&gt;&lt;/div&gt;&lt;hr color='#EB811B' size=1px width=796px&gt;&lt;/html&gt;


---

# Real pollution education example

&lt;center&gt;
&lt;img src="files/10-alex-nascar.png" width="80%" /&gt;
&lt;/center&gt;

---

# Real pollution education example

In .hi[3 hours], one NASCAR race emits more lead than a majority of industrial facilities do in an .hi[entire year]

.center[
![](10-slides-r_files/figure-html/tri histogram-1.svg)&lt;!-- --&gt;
]

---

# We will look at Florida

&lt;center&gt;
&lt;img src="files/10-florida-map.png" width="80%" /&gt;
&lt;/center&gt;

---

# All the data are public, you can look at scores yourself!

&lt;center&gt;
&lt;img src="files/10-fcat-site.png" width="80%" /&gt;
&lt;/center&gt;

---

# Let's look at the data


```r
nascar_df = read_csv("data/10-florida-nascar.csv") |&gt; 
  as_tibble() 
```

```
## Rows: 68858 Columns: 12
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: ","
## chr  (1): school_name
## dbl (11): school_id, grade, year, zscore, nascar_lead, nascar_lead_weighted,...
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.
```

```r
nascar_df
```

```
## # A tibble: 68,858 × 12
##    school_id school_name   grade  year zscore nascar_lead nascar_lead_weighted
##        &lt;dbl&gt; &lt;chr&gt;         &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;       &lt;dbl&gt;                &lt;dbl&gt;
##  1        56 HAMILTON ELEM     3  2003 -0.186        72.2                 2.53
##  2        56 HAMILTON ELEM     4  2003  0.101        80.4                 2.81
##  3        56 HAMILTON ELEM     5  2003 -0.206        88.0                 3.08
##  4        56 HAMILTON ELEM     3  2004 -0.686        74.0                 2.59
##  5        56 HAMILTON ELEM     4  2004 -0.633        82.4                 2.88
##  6        56 HAMILTON ELEM     5  2004  0.352        90.5                 3.17
##  7        56 HAMILTON ELEM     3  2005 -1.14         77.0                 2.69
##  8        56 HAMILTON ELEM     4  2005 -0.649        84.7                 2.97
##  9        56 HAMILTON ELEM     5  2005 -0.336        92.0                 3.26
## 10        56 HAMILTON ELEM     3  2006 -0.333        79.9                 2.80
## # … with 68,848 more rows, and 5 more variables: years_leaded &lt;dbl&gt;,
## #   industrial_lead &lt;dbl&gt;, median_income &lt;dbl&gt;, unemp_rate &lt;dbl&gt;,
## #   num_students &lt;dbl&gt;
```

---

# My sister is in these observations!


```r
nascar_df |&gt; # only keep Saturn Elementary School
  filter(school_name == "SATURN ELEM")
```

```
## # A tibble: 21 × 12
##    school_id school_name grade  year  zscore nascar_lead nascar_lead_weighted
##        &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;       &lt;dbl&gt;                &lt;dbl&gt;
##  1      2067 SATURN ELEM     3  2003  0.105            0                    0
##  2      2067 SATURN ELEM     4  2003 -0.0633           0                    0
##  3      2067 SATURN ELEM     5  2003  0.163            0                    0
##  4      2067 SATURN ELEM     3  2004  0.655            0                    0
##  5      2067 SATURN ELEM     4  2004  0.586            0                    0
##  6      2067 SATURN ELEM     5  2004  0.679            0                    0
##  7      2067 SATURN ELEM     3  2005  1.03             0                    0
##  8      2067 SATURN ELEM     4  2005  0.131            0                    0
##  9      2067 SATURN ELEM     5  2005  0.696            0                    0
## 10      2067 SATURN ELEM     3  2006  0.599            0                    0
## # … with 11 more rows, and 5 more variables: years_leaded &lt;dbl&gt;,
## #   industrial_lead &lt;dbl&gt;, median_income &lt;dbl&gt;, unemp_rate &lt;dbl&gt;,
## #   num_students &lt;dbl&gt;
```

---

# Let's look at the data


```r
summary(nascar_df)
```

```
##    school_id    school_name            grade            year     
##  Min.   :   3   Length:68858       Min.   :3.000   Min.   :2003  
##  1st Qu.: 961   Class :character   1st Qu.:3.000   1st Qu.:2006  
##  Median :1811   Mode  :character   Median :4.000   Median :2009  
##  Mean   :1832                      Mean   :3.998   Mean   :2009  
##  3rd Qu.:2702                      3rd Qu.:5.000   3rd Qu.:2012  
##  Max.   :4110                      Max.   :5.000   Max.   :2014  
##      zscore           nascar_lead    nascar_lead_weighted  years_leaded  
##  Min.   :-6.765987   Min.   : 0.00   Min.   :0.0000       Min.   :0.000  
##  1st Qu.:-0.630857   1st Qu.: 0.00   1st Qu.:0.0000       1st Qu.:0.000  
##  Median : 0.012807   Median : 0.00   Median :0.0000       Median :0.000  
##  Mean   : 0.000358   Mean   :12.88   Mean   :0.5145       Mean   :1.746  
##  3rd Qu.: 0.661761   3rd Qu.:16.38   3rd Qu.:0.5528       3rd Qu.:3.000  
##  Max.   : 4.884255   Max.   :92.02   Max.   :6.8524       Max.   :8.000  
##  industrial_lead   median_income     unemp_rate       num_students  
##  Min.   :      0   Min.   :25201   Min.   :0.02000   Min.   : 10.0  
##  1st Qu.: 300489   1st Qu.:41184   1st Qu.:0.04000   1st Qu.: 72.0  
##  Median : 562856   Median :44635   Median :0.06000   Median :100.0  
##  Mean   :1197073   Mean   :44712   Mean   :0.06359   Mean   :102.5  
##  3rd Qu.:2040709   3rd Qu.:48772   3rd Qu.:0.09000   3rd Qu.:130.0  
##  Max.   :6454837   Max.   :67238   Max.   :0.14000   Max.   :447.0
```

---

# The variables

- .hi[zscore]: the school's score for the average student in terms of standard deviations above or below the state-wide average
- .hi[nascar lead]: lifetime exposure to lead emissions from NASCAR tracks within 50 miles
- .hi[nascar lead weighted]: same as .hi[nascar lead], but counts emissions closer to the school more
- .hi[industrial lead]: lead emissions from industrial sources (e.g. factories) within 50 miles
- .hi[unemp rate]: the school district's unemployment rate
- .hi[median income]: the school district's median incoe
- .hi[num students]: the number of students at the school
- .hi[school id, school name, grade, and year]: self-explanatory

---

# What does the distribution of scores look like?


```r
hist(nascar_df$zscore)
```

![](10-slides-r_files/figure-html/unnamed-chunk-63-1.png)&lt;!-- --&gt;

---

# What about exposure to NASCAR lead

.pull-left[

```r
hist(nascar_df$nascar_lead)
```

![](10-slides-r_files/figure-html/unnamed-chunk-64-1.png)&lt;!-- --&gt;
]
.pull-right[

`hist(nascar_df$nascar_lead)` generates a histogram for a variable

Most schools have zero exposure

Some have a lot

Units are 10s of kilograms

]

---

# What about exposure to NASCAR lead

.pull-left[

```r
hist(nascar_df$nascar_lead_weighted)
```

![](10-slides-r_files/figure-html/unnamed-chunk-65-1.png)&lt;!-- --&gt;
]
.pull-right[
Most schools have zero exposure

Some have a lot
]

---

# What is the association between lead and scores?

.pull-left[

```
## `geom_smooth()` using method = 'gam'
```

![negatively correlated](10-slides-r_files/figure-html/pure_corr-1.png)
]

.pull-right[
Let's look at the pure correlation between test scores and lead

There's a lot of data so it's kind of hard to see but it appears there's a .hi-red[negative] association: lead is bad for test scores


]


---

# What is the association between lead and scores?

.pull-left[


![negatively correlated](10-slides-r_files/figure-html/binned-1.png)
]

.pull-right[

Lets .hi[bin] the data to see the pattern more clearly

All I'm doing is:

- Rounding lead to the nearest integer
- Taking the average of test scores for that bin
- Plot the average scores versus rounded lead


]

---

# What is the association between lead and scores?

We can get a better sense by running a regression: 
`$$zscore_{sgy} = \beta_0 + \beta_1 nascar_lead_weighted_{sgy}$$` `\((s\)` is school, `\(g\)` is grade, `\(y\)` is year)


```r
lm(zscore ~ nascar_lead_weighted, nascar_df) |&gt;
  broom::tidy()
```

The `broom::tidy()` at the end just makes the results look a bit cleaner on the screen

---

# What is the association between lead and scores?


```r
lm(zscore ~ nascar_lead_weighted, nascar_df) |&gt;
  broom::tidy()
```

```
## # A tibble: 2 × 5
##   term                 estimate 
##   &lt;chr&gt;               &lt;dbl&gt;      
## 1 (Intercept)           0.002   
*## 2 nascar_lead_weighted -0.004   
```

What does this mean?

An additional 10 kg of lead exposure is associated with a school having an average test score 0.004 standard deviations lower

---

# Do we believe this number?

What's a potential issue with just looking at the raw association?

--

Schools near NASCAR tracks are probably a lot different than schools further away

--

We want to control for things that are potentially correlated with both test scores and being close to NASCAR

--

Two broad important things: lead emissions from other sources, socioeconomic status

---

# Do we believe this number?


```r
lm(zscore ~ nascar_lead_weighted + industrial_lead + unemp_rate + median_income, nascar_df) |&gt;
  broom::tidy()
```
```
## # A tibble: 5 × 5
##   term                      estimate  
##   &lt;chr&gt;                        &lt;dbl&gt;  
## 1 (Intercept)          -0.846     
*## 2 nascar_lead_weighted -0.0008   (versus -0.004 above)
## 3 industrial_lead      -0.00000006
## 4 unemp_rate           -0.640    
## 5 median_income         0.00002
```

Controlling for other things matters: new estimate is 1/4 the size

---

# Why did this matter?

.pull-left[


![negatively correlated](10-slides-r_files/figure-html/income-1.png)
]

.pull-right[
Mainly because places with NASCAR tracks tend to be poorer:


```r
lm(median_income ~ nascar_lead_weighted, nascar_df)
```

```
## 
## Call:
## lm(formula = median_income ~ nascar_lead_weighted, data = nascar_df)
## 
## Coefficients:
##          (Intercept)  nascar_lead_weighted  
##              45057.8                -672.2
```
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
